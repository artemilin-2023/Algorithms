# Алгоритмы и структуры данных ![GitHub Repo stars](https://img.shields.io/github/stars/artemilin-2023/Algorithms)

Посчитал репозиторий полезным? Поставь звезду

Данный репозиторий содержит мою реализацию структрур и алгоритмов обработки данных из соответствующего курса лекций МАИ, а так же мое вольное описание принципа работы Алгоритмов/структур, на достоверность не претендую.

## Навигация

- [Алгоритмы и структуры данных ](#алгоритмы-и-структуры-данных-)
  - [Навигация](#навигация)
  - [Алгоритмы обработки данных](#алгоритмы-обработки-данных)
    - [Поиск](#поиск)
      - [Сравннение алгоритмов поиска](#сравннение-алгоритмов-поиска)
      - [Linear search](#linear-search)
      - [Sential search](#sential-search)
      - [Binary search](#binary-search)
    - [Сортировка](#сортировка)
      - [Сравннение алгоритмов сортировки](#сравннение-алгоритмов-сортировки)
      - [Сортировка пузырьком](#сортировка-пузырьком)

## Алгоритмы обработки данных

Я буду рассматривать только алгоритмы *поиска* и *сортировки*, алгоритмы оптимизации оставлю на потом.

### Поиск

Глобально алгоритмы поиска элемента в массиве делятся на линейные и бинарные. Преимущество линейного поиска заклчается в том, что для его работы нет ограничения на входные данные: поиск может осуществляться как в отсортированом массиве, так и не отсортированном. Бинарный поиск работает быстрее (в худшем случае), но требует, чтобы исходный массив был отсортирован.

#### Сравннение алгоритмов поиска

| Тип | Название | лучший случай | худший случай | память |
|-|:-:|:-:|:-:|:-:|
| Линейный | LinearSearch | $\Omega(1)$ | $O(n)$ | $O(1)$ |
| Линейный | SentialSearch | $\Omega(1)$ | $O(n)$ | $O(1)$ |
| Бинарный | BinarySearch | $\Omega(\log(n))$ | $O(\log(n))$ | $O(1)$ |

#### Linear search

Реализация [тут](https://github.com/artemilin-2023/Algorithms/blob/d902b9e2a85b5ab0832a85998bab512b2bb03d30/Algorithms/Searcher.cs#L12)

Классический линейный поиск. Принцип работы заключается в том, что в цикле поэлементно сравнивается текущее значение множества с искомым. Если мы перебрали весь исходный массив, а искомый элемент так и не нашелся, возвращается значение -1.

#### Sential search

Реализация [тут](https://github.com/artemilin-2023/Algorithms/blob/d902b9e2a85b5ab0832a85998bab512b2bb03d30/Algorithms/Searcher.cs#L30)

Принцип работы похож на обычный линейный поиск, за тем исключением, что время одной итерации меньше за счёт отсутствия проверки выхода за границу массива.

#### Binary search

Реализация [тут](https://github.com/artemilin-2023/Algorithms/blob/d902b9e2a85b5ab0832a85998bab512b2bb03d30/Algorithms/Searcher.cs#L53)

Идея заключается в том, что мы "сужаем" диапазон, в котором может находиться искомый элемент, учитывая то, что мы знаем, с какого индекса находятся элементы меньше искомого, а с какого - больше.

Алгоритм:

1. Определяется значение элемента в середине массива. Полученное значение сравнивается с искомым элементом.
2. Если искомый элемент меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй.
3. Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с искомым элеменом.
4. Процесс продолжается до тех пор, пока не будет найден элемент со значением искомого или не станет пустым интервал для поиска.

![binsearch](./readme-source/binsearch.jpg)

### Сортировка

Алгоритмов сортировки существует множество, я рассмотрю только несколько наиболее популярных.

#### Сравннение алгоритмов сортировки

| Название | Средний случай | Худший случай | Память |
|-|:-:|:-:|:-:|
| Сортировка пузырьком | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| Сортировка вставками | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| Сортировка выбором | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| Сортировка слиянием | $O(n*log(n))$ | $O(n*log(n))$ | $O(n)$ |
| Быстрая сортировка | $O(n*log(n))$ | $O(n^2)$ | $O(log(n))$ |
| Параллельная сортировка слиянием | $O(n)$ | $O(n)$ | $O(n)$ |

#### Сортировка пузырьком

Реализация [тут](https://github.com/artemilin-2023/Algorithms/blob/c42a07fd36d09cd61f4c6b1b618804967504d7aa/Algorithms/Sorting.cs#L148)

Простейшая для реализации и понимания сортирровка. Принцип работы заключается в выполнении нескольких проходов по массиву: начиная от $i+1$ элемента, перебираются соседние пары. Если левый элемент пары больше правого, то они меняются местами (при сортировке по возрастанию).

Псевдокод:

``` C#
ЦИКЛ ДЛЯ I=0 ДО n-1 ШАГ 1
   ЦИКЛ ДЛЯ J=I+1 ДО n ШАГ 1
     ЕСЛИ A[J - 1] > A[j] ТО ОБМЕН A[j - 1], A[j]
   СЛЕДУЮЩЕЕ j
 СЛЕДУЮЩЕЕ I
```

![bubble sort](./readme-source/Bubble-sort-example-300px.gif)
